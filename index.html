<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>NixOS per DevOps</title>
<meta name="author" content="Nix build user"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/dist/theme/black.css" id="theme"/>
<link rel="stylesheet" href="./reveal.js/plugin/highlight/zenburn.css"/>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide">
<h1>NixOS per DevOps<h1>
</section>

<section>
<section id="slide-org41653b7">
<h2 id="org41653b7">Contenuti</h2>
<ul>
<li class="fragment appear">Cosa sono Nix e NixOS</li>
<li class="fragment appear">Perche' NixOS si presta bene per fare DevOps</li>
<li class="fragment appear">CI/CD con NixOS</li>
<li class="fragment appear">Un caso d'uso</li>

</ul>

</section>
<section id="slide-orgebf991c">
<h3 id="orgebf991c">Disclaimer</h3>
<aside class="notes">
<ul>
<li>La mia esperienza nel mondo DevOps in modo full-time e' iniziata 2 anni fa, e con Nix!</li>
<li>Prima facevo full stack dev, quindi ho visto tecnologie piu' tradizionali ma non sono un esperto e potrei non essere il migliore per fare confronti, pertanto provero' ad astenermi</li>
<li>cerchero' di distinguere bene tra le mie opinioni e i fatti</li>
<li>lo scopo e' fare una panoramica sulle possibilita' stuzzicando l'appetito</li>
<li>questa presentazione e' un'alpha, mi piacerebbe ricevere feedback e che possa essere integrata in futuro</li>
<li>non sono nemmeno piu' sicuro che il titolo della presentazione abbia senso</li>

</ul>

</aside>
<ul>
<li class="fragment appear">Ma <code>x</code> lo posso fare anche con <code>y</code>!</li>
<li class="fragment appear">Il mio approccio con Nix e' ortodosso, ma nulla vieta un'integrazione solo parziale</li>
<li class="fragment appear">Molte opinioni personali</li>
<li class="fragment appear">Sacrifichero' un po' precisione a favore di una migliore digeribilita'</li>
<li class="fragment appear">Certe parti sono scarne, questa presentazione e' open source, aiutatemi a migliorarla!</li>

</ul>

</section>
</section>
<section>
<section id="slide-org3eee928">
<h2 id="org3eee928">Nix</h2>

<div id="orgd1838f4" class="figure">
<p><img src="./pics/the-declarative-trinity.webp" alt="the-declarative-trinity.webp" />
</p>
</div>

</section>
<section id="slide-orgb400ecf">
<h3 id="orgb400ecf">Nix come linguaggio</h3>
<aside class="notes">
<ul>
<li>il fatto che sia lazy o funzionale puro non e' cosi' fondamentale in realta' (forse e' il motivo del relativamente scarso successo negli anni, anche se la situazione sta cambiando)</li>

</ul>

</aside>
<p>
Nix e' un DSL funzionale lazy pensato per restituire una struttura chiamata <b><b>derivazione</b></b>
</p>

</section>
<section id="slide-orgc7a06b7">
<h3 id="orgc7a06b7">Derivazione</h3>
<aside class="notes">
<ul>
<li>Quasi mai si usa direttamente <code>builtins.derivations</code></li>
<li>questo estratto non valuta, manca lo scope</li>

</ul>

</aside>
<div class="org-src-container">

<pre><code class="nix" >stdenv.mkDerivation {
  name = "hello";

  src = ./src;

  buildInputs = [ coreutils gcc ];

  buildPhase = ''
    gcc "$src/hello.c" -o ./hello
  '';
  installPhase = ''
    mkdir -p "$out/bin"
    cp ./hello "$out/bin/"
  '';
}
</code></pre>
</div>

<ul>
<li>la sintassi ricorda JSON, ma e' Turing completo! (condizioni, funzioni, etc&#x2026;)</li>
<li><code>stdenv.mkDerivation</code> wrappa <code>builtins.derivation</code></li>

</ul>

</section>
<section>
<aside class="notes">
<p>
Nel linguaggio comune per derivazione si intendono almeno tre cose:
</p>
<ul>
<li>l'oggetto in memoria ad eval time</li>
<li>il file <code>.drv</code></li>
<li>l'output della derivazione</li>

</ul>

</aside>
<p>
Quando l'evaluator Nix valuta una derivazione crea un file <code>.drv</code>
</p>

<pre>
{
  "/nix/store/z3hhlxbckx4g3n9sw91nnvlkjvyw754p-myname.drv": {
    "outputs": {
      "out": {
        "path": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname"
      }
    },
    "inputSrcs": [],
    "inputDrvs": {},
    "platform": "mysystem",
    "builder": "mybuilder",
    "args": [],
    "env": {
      "builder": "mybuilder",
      "name": "myname",
      "out": "/nix/store/40s0qmrfb45vlh6610rk29ym318dswdr-myname",
      "system": "mysystem"
    }
  }
}
</pre>

<aside class="notes">
<p>

</p>

</aside>

</section>
<section id="slide-org8f48d79">
<h3 id="org8f48d79">Build della derivazione</h3>
<p class="fragment (appear)">
Il file <code>drv</code> contiene tutte le informazioni necessarie per costruire l'output della derivazione.
</p>

<p class="fragment (appear)">
Se la derivazione dipende da altre derivazioni prima vengono buildate queste.
</p>

</section>
<section id="slide-orgbbc6e55">
<h3 id="orgbbc6e55">Input addressed vs content addressed</h3>
<p class="fragment (appear)">
<b>Input addresssed</b>: l'output della derivazione finira' in un path che contiene un hash ottenuto partendo alcune informazioni tra cui il nome, la versione, il builder e <b>i nomi degli input</b> (quindi dai loro hash).
</p>

<p class="fragment (appear)">
In questo modo e' possibile sapere l'output di una derivazione <b>prima di buildarla</b>.
</p>

<p class="fragment (appear)">
Le build avvengono in ambienti <b>sandboxed</b> senza accesso al sistema (in particolare a internet), in sostanza <b>dipendono solo dalle derivazioni input</b>.
</p>

</section>
<section>
<p>
Come possiamo buildare qualcosa se non possiamo scaricarne i sorgenti?
</p>

<p class="fragment (appear)">
<b>Fixed output</b>: se siamo in grado di esplicitare l'hash del contenuto nel file <code>drv</code> (prima che avvenga la build) allora la sandbox dove avverra' la build avra' accesso a internet (<code>git</code>, <code>curl</code>, etc&#x2026;)
</p>

<p class="fragment (appear)">
Corollario: risalendo il grafo delle dipendenze di una derivazione alla fine troveremo sempre derivazioni <b>fixed output</b>.
</p>

<p class="fragment (appear)">
Sono dette anche <b>content addressed</b>.
</p>

</section>
<section id="slide-org4891a80">
<h3 id="org4891a80">Demo</h3>
<p>
<a href="https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/games/umoria/default.nix">https://github.com/NixOS/nixpkgs/blob/nixos-unstable/pkgs/games/umoria/default.nix</a>
</p>

<pre>
nix derivation show nixpkgs#umoria
nix build nixpkgs#umoria -L --rebuild
</pre>

</section>
<section id="slide-orga5ae844">
<h3 id="orga5ae844">Nix store</h3>
<aside class="notes">
<ul>
<li>Mostrare /nix/store</li>
<li>Sia file `drv` che output finiscono qui</li>
<li>lo store e' immutabile, le derivazioni una volta buildate non cambiano mai</li>
<li>lo store e' leggibile da tutti</li>

</ul>

</aside>
<p class="fragment (appear)">
Dove finiscono gli output delle derivazioni?
</p>


<div id="org491faad" class="figure">
<p><img src="./pics/store.webp" alt="store.webp" height="80%" class="fragment (appear)" />
</p>
</div>


</section>
<section id="slide-orgb0cb7d3">
<h3 id="orgb0cb7d3">Dipendenze e closure</h3>
<aside class="notes">
<ul>
<li>citare garbage collector</li>
<li>copiare solo drv ed effettuare build remote</li>
<li>build distribuite</li>

</ul>

</aside>

<p class="fragment (appear)">
Nix quindi e' in grado di gestire contemporaneamente diverse versioni delle stesse dipendenze.
</p>

<p class="fragment (appear)">
Potremo per esempio avere sullo stesso sistema versioni diverse di uno stesso software che pero' richiedono dipendenze differenti (dependency hell).
</p>

</section>
<section>
<p>
Data una derivazione, e' possibile considerare la chiusura rispetto alla relazione di dipendenza di tale derivazione, ovvero la <b>closure</b>.
</p>

<p class="fragment (appear)">
Pertanto possiamo copiare un programma con tutte le sue dipendenze da una macchina all'altra semplicemente copiando la closure.
</p>

</section>
<section id="slide-orgfeaecb5">
<h3 id="orgfeaecb5">Cache</h3>
<aside class="notes">
<ul>
<li>citare trustix (distributed build)</li>

</ul>

</aside>


<div id="org976e31f" class="figure">
<p><img src="./pics/caches-are-fast.png" alt="caches-are-fast.png" height="80%" class="fragment (appear)" />
</p>
</div>

<p class="fragment (appear)">
Nix prima di buildare una derivazione (un file <code>drv</code>) interroga un <b>substituter</b> (detto anche <b>cache</b>) ed eventualmente scarica l'output della derivazione.
</p>

<p class="fragment (appear)">
Cio' e' possibile poiche' gli output sono (generalmente) <b>input addressed</b>.
</p>

</section>
</section>
<section>
<section id="slide-orgc559cb5">
<h2 id="orgc559cb5">NixOS</h2>
<p class="fragment (appear)">
E se l'intero sistema operativo fosse l'output di una derivazione?
</p>

</section>
<section id="slide-orga8acd5b">
<h3 id="orga8acd5b">Caratteristiche</h3>
<p>
In ordine sparso:
</p>

<ul>
<li class="fragment appear">dichiarativo</li>
<li class="fragment appear">Linux</li>
<li class="fragment appear">usa <code>systemd</code></li>
<li class="fragment appear">puo' essere rolling release (in realta' fanno release)</li>

</ul>

</section>
<section id="slide-orgfd559e9">
<h3 id="orgfd559e9">Module system</h3>
<aside class="notes">
<p>
Sono stati inventati per NixOS ma vengono usati anche all'interno di altri progetti.
Idea vincente IMO.
Usare solo le funzioni come astrazione quando si hanno cosi' tante opzioni (argomenti?) diventa ingestibile
Esempio: <a href="https://github.com/NixOS/nixpkgs/tree/nixos-unstable/nixos/modules/services/continuous-integration/github-runner">https://github.com/NixOS/nixpkgs/tree/nixos-unstable/nixos/modules/services/continuous-integration/github-runner</a>
</p>

</aside>

<p class="fragment (appear)">
Nix non e' strong typed, i moduli aggiungono un type system <b>dentro il linguaggio stesso</b>.
</p>

<p class="fragment (appear)">
Sono estremamente componibili.
</p>

</section>
<section>
<p>
Sostanzialmente un modulo fa due cose:
</p>
<ul>
<li class="fragment appear">dichiara opzioni (nomi, tipi, valori di esempio, valori di default, documentazione, etc&#x2026;)</li>
<li class="fragment appear">imposta altre opzioni (di altri moduli) partendo dai valori delle sue opzioni</li>

</ul>

</section>
<section id="slide-org3bdd5cb">
<h3 id="org3bdd5cb">Flakes</h3>
<aside class="notes">
<p>
Sono il futuro, anche se ufficialmente ancora unstable consiglio di iniziare usandoli.
Accennare i canali.
</p>

</aside>


<div id="org584c114" class="figure">
<p><img src="./pics/fleyks.png" alt="fleyks.png" width="50%" />
</p>
</div>

</section>
<section>
<p>
Il linguaggio diventa veramente puro (e.g. non puo' leggere path fuori dallo store).
</p>

<p class="fragment (appear)">
Forniscono un modo unificato di dichiarare le dipendenze dei propri progetti ed interagire con essi da CLI.
</p>

</section>
<section>

<p>
Schema di un flake:
</p>
<div class="org-src-container">

<pre><code class="nix" >{ self, ... }@inputs:
{
  # Executed by `nix flake check`
  checks."&lt;system&gt;"."&lt;name&gt;" = derivation;
  # Executed by `nix build .#&lt;name&gt;`
  packages."&lt;system&gt;"."&lt;name&gt;" = derivation;
  # Executed by `nix build .`
  packages."&lt;system&gt;".default = derivation;
  # Executed by `nix run .#&lt;name&gt;`
  apps."&lt;system&gt;"."&lt;name&gt;" = {
    type = "app";
    program = "&lt;store-path&gt;";
  };
  # Executed by `nix run . -- &lt;args?&gt;`
  apps."&lt;system&gt;".default = { type = "app"; program = "..."; };

  # Formatter (alejandra, nixfmt or nixpkgs-fmt)
  formatter."&lt;system&gt;" = derivation;
  # Used for nixpkgs packages, also accessible via `nix build .#&lt;name&gt;`
  legacyPackages."&lt;system&gt;"."&lt;name&gt;" = derivation;
  # Overlay, consumed by other flakes
  overlays."&lt;name&gt;" = final: prev: { };
  # Default overlay
  overlays.default = final: prev: { };
  # Nixos module, consumed by other flakes
  nixosModules."&lt;name&gt;" = { config, ... }: { options = {}; config = {}; };
  # Default module
  nixosModules.default = { config, ... }: { options = {}; config = {}; };
  # Used with `nixos-rebuild switch --flake .#&lt;hostname&gt;`
  # nixosConfigurations."&lt;hostname&gt;".config.system.build.toplevel must be a derivation
  nixosConfigurations."&lt;hostname&gt;" = {};
  # Used by `nix develop .#&lt;name&gt;`
  devShells."&lt;system&gt;"."&lt;name&gt;" = derivation;
  # Used by `nix develop`
  devShells."&lt;system&gt;".default = derivation;
  # Hydra build jobs
  hydraJobs."&lt;attr&gt;"."&lt;system&gt;" = derivation;
  # Used by `nix flake init -t &lt;flake&gt;#&lt;name&gt;`
  templates."&lt;name&gt;" = {
    path = "&lt;store-path&gt;";
    description = "template description goes here?";
  };
  # Used by `nix flake init -t &lt;flake&gt;`
  templates.default = { path = "&lt;store-path&gt;"; description = ""; };
}
</code></pre>
</div>

</section>
<section id="slide-orgd616c91">
<h3 id="orgd616c91">nixpkgs</h3>
<p>
Contiene sia pacchetti (derivazioni) che moduli di NixOS.
</p>

<p>
<a href="https://github.com/nixos/nixpkgs">https://github.com/nixos/nixpkgs</a>
</p>

<p>
<a href="https://repology.org/repositories/graphs">https://repology.org/repositories/graphs</a>
</p>

<p>
<a href="https://search.nixos.org/">https://search.nixos.org/</a>
</p>


</section>
</section>
<section>
<section id="slide-orgff2245e">
<h2 id="orgff2245e">Deploy</h2>
<p class="fragment (appear)">
<code>nixos-rebuild</code> in realta' permette anche il deploy remoto.
</p>

<pre class="fragment (appear)">
nixos-rebuild switch --flake github:aciceri/nixfleet#kirk --target-host X.X.X.X --build-host Y.Y.Y.Y
</pre>

</section>
<section>

<p>
Esistono numeri altri tool:
</p>
<ul>
<li><code>nixops</code></li>
<li><code>colmena</code></li>
<li><code>deploy-rs</code></li>
<li>altri</li>

</ul>

</section>
<section>

<p>
E se volessimo generare immagini per provider cloud specifici?
</p>

<ul>
<li class="fragment appear">AWS</li>
<li class="fragment appear">Google Cloud</li>
<li class="fragment appear">Azure</li>
<li class="fragment appear">molti altri</li>

</ul>

<p class="fragment (appear)">
<a href="https://github.com/nix-community/nixos-generators" class="fragment (appear)">https://github.com/nix-community/nixos-generators</a>
</p>


</section>
</section>
<section>
<section id="slide-org17305fa">
<h2 id="org17305fa">Cosa non risolve Nix(OS)</h2>
<p class="fragment (appear)">
Niente.
</p>

<p class="fragment (appear)">
Dico davvero.
</p>

<p class="fragment (appear)">
Ok, quasi niente.
</p>

</section>
<section>

<p>
NixOS non e':
</p>
<ul>
<li class="fragment appear">Terraform</li>
<li class="fragment appear">Kubernetes</li>
<li class="fragment appear">???</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgf1c7b54">
<h2 id="orgf1c7b54">CI/CD</h2>
<p class="fragment (appear)">
Se i progetti su cui lavorano gli sviluppatori sono flake, la CI puo' semplicmente buildare un sottoinsieme dei suoi output (<code>packages</code>, <code>checks</code>, <code>devShells</code>, etc&#x2026;).
<b>I progetti non richiedono nessuna configurazione ad hoc per abilitare la CI</b>.
</p>

<p class="fragment (appear)">
Se lo store del sistema di CI persiste avremo build molto veloci. Altrimenti e' possibile istruire la CI a pushare cio' che builda su una cache (e interrogarla prima di buildare).
</p>

<p class="fragment (appear)">
Se esponiamo questa cache agli sviluppatori minimizzeremo di molto il tempo di build in locale.
</p>

</section>
<section>

<aside class="notes">
<p>
Citare cachix - cache as a service
Citare la mia CI
Osservare come il deploy remote da CI puo' anche prevedere che la build avvenga sulla macchina remota (per esempio se la macchina che esegue la CI e' poco potente)
</p>

</aside>

<p>
Esistono diverse soluzioni:
</p>

<ul>
<li class="fragment appear">GitHub actions (esistono actions per installare Nix e configurarlo per usare una cache)</li>
<li class="fragment appear">Hydra (CI ufficiale di nixpkgs, compatibile con diverse forgie)</li>
<li class="fragment appear">Hercules CI</li>
<li class="fragment appear">molti altri&#x2026;</li>

</ul>
</section>
<section>

<p>
Il continuous deployment viene facile, basta eseguire uno dei tool visti prima in CI.
</p>

<p class="fragment (appear)">
Esistono soluzioni piu' strutturate per gestire il deploy di sistemi multipli (come Hercules CI).
</p>

<p class="fragment (appear)">
Alternativamente si puo' anche istruire il sistema stesso ad aggiornarsi da solo:
</p>

<div class="org-src-container">

<pre class="fragment (appear)"><code class="nix" >system.autoUpgrade = {
  enable = true;
  flake = "github:aciceri/nixfleet#${config.networking.hostName}";
  dates = "daily";
  allowReboot = false;
};
</code></pre>
</div>

</section>
</section>
<section>
<section id="slide-orgacfc93c">
<h2 id="orgacfc93c">Chicche</h2>

</section>
<section id="slide-org641b503">
<h3 id="org641b503">Cross-compilazione</h3>
<aside class="notes">
<p>
Molti provider oggigiorno offrono host in cloud ARM, e sono piu' economici!
Ah comunque Nix supporta svariate architetture, tra cui anche darwin (x86 e ARM).
</p>

<p>
Nella definizione delle derivazioni non appare `gcc`, bensi' la variabile `$CC`
</p>

<p>
nix build nixpkgs#legacyPackages.x86<sub>64</sub>-linux.pkgsCross.riscv64.hello -L &#x2013;rebuild
nix build nixpkgs#legacyPackages.aarch64-linux.hello -L
</p>

</aside>

<p>
Nix permette di "cross-buildare" le derivazioni in due modi diversi, e funzionano entrambi molto bene.
</p>
<ul>
<li class="fragment appear">vera cross-compilazione</li>
<li class="fragment appear"><code>binfmt</code> (QEMU)</li>

</ul>

</section>
<section id="slide-orgc17dbbb">
<h3 id="orgc17dbbb">Docker</h3>
<p>
Nix e' probabilmente un migliore build system per Docker di Docker stesso.
</p>

<ul>
<li class="fragment appear">miglior caching (no "layering lineare")</li>
<li class="fragment appear">vera riproducibilita'</li>
<li class="fragment appear">le immagini Docker non sono altro che derivazioni Nix</li>
<li class="fragment appear">accesso a tutto nixpkgs (quantita' spropositata di pacchetti)</li>
<li class="fragment appear">cross-building migliore (<code>docker buildx</code> 🤮)</li>

</ul>
</section>
<section>

</section>
<section id="slide-org378174e">
<h3 id="org378174e">Segreti</h3>
<aside class="notes">
<p>
Soluzione banale: integrare qualcosa che copi i segreti nel nostro sistema di deploy.
Ma noi vogliamo evitare che lo stato del nostro sistema dipenda dallo stato di qualcosa di esterno, sarebbe bello se la derivazione del sistema dipendesse anche dai segreti.
</p>

</aside>


<div id="org52f3550" class="figure">
<p><img src="./pics/segreto.png" alt="segreto.png" width="50%" />
</p>
</div>

</section>
<section>
<p>
Come possiamo avere segreti se le derivazioni nello store sono leggibili da tutti?
</p>

<p class="fragment (appear)">
Criptiamoli!
</p>
<ul>
<li class="fragment appear"><code>agenix</code></li>
<li class="fragment appear"><code>sops-nix</code></li>

</ul>

<p class="fragment (appear)">
Mettiamo nello store solo i segreti criptati e installiamo degli script che li decriptino a runtime.
</p>

<p class="fragment (appear)">
Questo richiede comunque un meccanismo per distrubuire la chiave privata in fase di deploy.
</p>

</section>
<section id="slide-orgd30deb6">
<h3 id="orgd30deb6">Disko</h3>
<aside class="notes">
<p>
Risultato pratico in fase d'installazione:
</p>
<ul>
<li>avvio la live</li>
<li>lancio lo script che crea le partizioni e formatta tutto</li>
<li>monto tutto in <code>/mnt</code> manualmente (solo ora durante l'installazione ovviamente)</li>
<li>lancio <code>nixos-install</code> (sotto fa <code>chroot</code> e <code>nixos-rebuild install</code>)</li>

</ul>

</aside>

<p>
NixOS fornisce opzioni che definiscono i punti di mount del sistema, ma durante l'installazione queste partizioni devono essere create manualmente.
</p>

<p class="fragment (appear)">
Disko e' un modulo NixOS che permette di dichiarare come devono essere create le partizioni (dimensione, file system, encryption, etc&#x2026;)
</p>

<p class="fragment (appear)">
Tale modulo fa due cose:
</p>
<ul>
<li class="fragment appear">setta i punti di mount (settando le opzioni di NixOS che altrimenti sarebbero state settate manualmente i.e. <code>fileSystems</code>)</li>
<li class="fragment appear">definisce uno script che formatta automaticamente</li>

</ul>

</section>
<section id="slide-org7341005">
<h3 id="org7341005">Impermanence</h3>
<aside class="notes">
<p>
Fare bind mount e' concesso per non creare 85 partizioni per lo stato di ogni singola applicazione
</p>

</aside>

<p>
NixOS e' stateless?
</p>

<p class="fragment (appear)">
Purtroppo no&#x2026; 
</p>

<p class="fragment (appear)">
Ma possiamo domare lo stato!
</p>

</section>
<section>

<p>
<a href="https://github.com/nix-community/impermanence">https://github.com/nix-community/impermanence</a>
</p>

<ul>
<li class="fragment appear">e' un modulo NixOS</li>
<li class="fragment appear"><code>tmpfs</code> come <code>/</code> (tranne <code>/boot</code> e <code>/nix</code>)</li>
<li class="fragment appear">elenchiamo tutto cio' che deve persistere (e lo mettamo in una partizione seperata)</li>
<li class="fragment appear">ci forza a sapere dove si trova lo stato delle nostre applicazioni, quindi sappiamo cosa backuppare</li>

</ul>

</section>
<section id="slide-orgc39cc60">
<h3 id="orgc39cc60">NixOS anywhere</h3>
<aside class="notes">
<ul>
<li>Aruba</li>
<li>kexec (feature di linux per bootare un nuovo kernel senza riavviare)</li>
<li>usa <code>disko</code></li>
<li>E' il mio metodo di installazione preferito, anche per macchine fisiche, portare esempio del laptop in uso</li>

</ul>

</aside>

<p>
Il mio cloud provider non supporta NixOS&#x2026; 😭
</p>

<p class="fragment (appear)">
<a href="https://github.com/nix-community/nixos-anywhere" class="fragment (appear)">https://github.com/nix-community/nixos-anywhere</a>
</p>

<p class="fragment (appear)">
Per gli amanti di terraform esiste un anche un interessante modulo.
</p>



</section>
</section>
<section>
<section id="slide-orge75014d">
<h2 id="orge75014d">Nix pizza</h2>
<ul>
<li class="fragment appear">"collettivo" di appassionati di Nix in Italia (ciao <a href="https://github.com/zarelit">@zarelit</a>!)</li>
<li class="fragment appear"><a href="https://github.com/nix-pizza/infra">https://github.com/nix-pizza/infra</a></li>
<li class="fragment appear">liberta' di sperimentare soluzioni esotiche</li>
<li class="fragment appear">Self-hosting di servizi</li>
<li class="fragment appear">Demo time</li>

</ul>


</section>
</section>
<section>
<section id="slide-orgbc9ee11">
<h2 id="orgbc9ee11">Questa presentazione</h2>
<aside class="notes">
<ul>
<li>il fatto che e' un flake semplifica la distribuzione e la riproducibilita'</li>
<li>l'alternativa ovvia per questo compito e' Docker, nix e' meglio in questo caso perche':</li>
<li>piu' snello</li>
<li>davvero riproducibile</li>
<li>installare pacchetti Emacs da un docker file non e' agevole come fatto qui con Nix</li>
<li>CI gratis semplicemente buildando tutti gli output del flake</li>
<li>CD molto facile grazie agli Hercules CI effects</li>

</ul>

</aside>
<ul>
<li class="fragment appear"><p>
e' un flake
</p>
<pre>
nix build github:aciceri/nixos-devops-talk
</pre></li>
<li class="fragment appear">e' scritta in org-mode</li>
<li class="fragment appear">buildata con Nix</li>
<li class="fragment appear">pubblicata su GitHub Pages usando Hercules CI</li>

</ul>

</section>
<section id="slide-org57a5198">
<h3 id="org57a5198">Repository</h3>
<p>
<a href="https://github.com/aciceri/nixos-devops-talk">https://github.com/aciceri/nixos-devops-talk</a>
</p>

<div id="org2d10687" class="figure">
<p><img src="./pics/qr.png" alt="qr.png" width="50%" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-org41bd915">
<h2 id="org41bd915">Domande</h2>
<p>
Non troppo difficili per favore!
</p>
</section>
</section>
</div>
</div>
<script src="./reveal.js/dist/reveal.js"></script>
<script src="./reveal.js/plugin/math/math.js"></script>
<script src="./reveal.js/plugin/markdown/markdown.js"></script>
<script src="./reveal.js/plugin/highlight/highlight.js"></script>
<script src="./reveal.js/plugin/notes/notes.js"></script>
<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 't',
rollingLinks: false,
keyboard: true,
mouseWheel: false,
fragmentInURL: true,
hashOneBasedIndex: false,
pdfSeparateFragments: true,
overview: true,
width: 1400,
height: 1000,

transition: 'convex',
transitionSpeed: 'default',

// Plugins with reveal.js 4.x
plugins: [ RevealMath, RevealMarkdown, RevealHighlight, RevealNotes ],

// Optional libraries used to extend reveal.js
dependencies: [
]

});
</script>
</body>
</html>
